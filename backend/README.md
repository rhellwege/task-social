# Task Social Backend
This project uses fiber for an http framework, sqlc for sql query codegen and swagger for manual testing and documentation of apis.

## Structure
- cmd/ contains the main binary
- internal/ contains all core functionality
- internal/api contains the api implementation
- internal/db contains code to interact with and initialize the database
The structure of this project loosely follows the CLEAN architecture so that each component has a specific domain and is easily mockable through dependency injection. The presentation layer is the handler layer, this layer is responsible for handling the http requests and transforming the data into json to be returned. The middleware layer can also be considered handlers since they deal with http requests but are applicable to multiple handlers. The handler layer calls into the service layer which is responsible for the business logic. This layer sits on top of the repository layer which is responsible for storing data. The repository layer is generated by sqlc however, we could abstract it further by creating an interface for it to allow for a mock database. Each layer is defined by an interface so that there can be multiple implementations.
- A vertical slice of this API would look like this: route->(middleware)->handler->service->repository->db

## Code Generation
sqlc and swagger are used to generate code for database queries and models as well as api documentation. internal/docs is where swagger generates the documentation and internal/db/models is where sqlc generates the models and queries.

## Sqlc
This project uses sql queries that are used to generate code inside the models package.
https://docs.sqlc.dev/en/stable/reference/config.html
## Swagger
Swagger (swaggo) is used to document api endpoints and manual test the api.
handlers are documented with comments. To generate the swagger page run ```swag init -g cmd/main.go```
When the server is running, the swagger page can be accessed at http://localhost:5050/swagger/index.html

### How To Use
Since almost all routes are protected by jwt authentication, you will need to generate a token to use for testing. To generate a token, you will have to either register a new user or login with an existing user.

The response will contain the token in the "token" field. Copy that token then click the green Authorize button in the top right corner of the swagger page and paste it into the header value input.
## Testing
Inside each service, there is a go:generate comment that generates mocks inside a mocks package. The unit tests will import those mocks and use them to test the service layer.
